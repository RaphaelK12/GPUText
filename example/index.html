<!DOCTYPE html>
<html>
<head>
	<meta charset="utf-8" />
	<title>MSDF</title>
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<style>
		body {
			font-family: helvetica, sans-serif;
		}

		#error-log {
			position: absolute;
			top: 20px;
			left: 20px;
			z-index: 1;
			color: green;
			font-weight: bold;
			font-size: 1.2em;
		}
	</style>
</head>
<body>
	<pre id="error-log"></pre>
	<canvas width="1024px" height="768px"></canvas>

	<div style="position: absolute; top: 20px; left: 20px; color: white; user-select: none;">
		<label for="debug-mode">Debug Mode</label><input type="checkbox" id="debug-mode">
		<label for="text-size">Size</label><input type="range" min="0" max="1" value="0.5" class="slider" id="text-size">
	</div>

	<script src="../gputext.js"></script>
	<script src="../gputext-webgl.js"></script>

	<script>
		"use strict";
		let canvas = document.querySelector('canvas');

		// use full DPI of display
		let devicePixelRatio = window.devicePixelRatio || 1;
		canvas.width = Math.round(canvas.clientWidth * devicePixelRatio);
		canvas.height = Math.round(canvas.clientHeight * devicePixelRatio);
		canvas.style.width = (100 / devicePixelRatio) + '%';
		canvas.style.height = (100 / devicePixelRatio) + '%';

		let gl = canvas.getContext('webgl', {antialias: false});

		// app state
		let textBuffer = null;
		let glyphAtlasTexture = null;

		let textTransform = new Float32Array([
			1.0, 0.0, 0.0, 0.0,
			0.0, 1.0, 0.0, 0.0,
			0.0, 0.0, 1.0, 0.0,
			0.0, 0.0, 0.0, 1.0,
		]);
		let glyphAtlasTextureUnit = 0;

		// initialize MSDF program
		let msdfProgram = GPUTextWebGL.createTextProgram(gl, {});
		// let fontName = 'Neuton-Regular';
		let fontName = 'OpenSans-Regular';
		// load font and generate text buffer
		let font = null;
		fetch(`${fontName}.json`)
			.then((response) => {
				if (response.status != 200) {
					throw `HTTP Response "${response.status} ${response.statusText}" for ${response.url}`;
				} else {
					return response.json();
				}
			})
			.then((json) => {
				font = json;
				textBuffer = GPUTextWebGL.createTextBuffer(gl, [
					{text: 'Lorem ipsum dolor sit amet, consectetur adipiscing elit.', font: font},
				], {});
				console.log('Created text buffers', textBuffer);
			})
			.catch(logError);

		let image = new Image();
		image.addEventListener('load', function(e) {
			glyphAtlasTexture = GPUTextWebGL.createGlyphAtlas(gl, image);
		});
		image.src = `${fontName}-0.png`;

		// debug
		let msdfDebugProgram = GPUTextWebGL.createTextProgram(gl, {}, null, `
			precision mediump float;     

			uniform vec4 color;
			varying vec2 vUv;

			void main() { gl_FragColor = color; }
		`);
		let debugModeCheckbox = document.getElementById('debug-mode');
		let debugSize = document.getElementById('text-size');
		debugSize.step = 0.01;

		let baselineBuffer = gl.createBuffer();
		let baselineTransform = new Float32Array([
			1.0, 0.0, 0.0, 0.0,
			0.0, 1.0, 0.0, 0.0,
			0.0, 0.0, 1.0, 0.0,
			0.0, 0.0, 0.0, 1.0,
		]);
		gl.bindBuffer(gl.ARRAY_BUFFER, baselineBuffer);
		gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([-1, 0, 1, 0]), gl.STATIC_DRAW);

		// begin rendering
		// set unchanging state
		gl.disable(gl.DEPTH_TEST);
		gl.disable(gl.STENCIL_TEST);
		gl.disable(gl.SCISSOR_TEST);

		gl.enable(gl.CULL_FACE);

		// premultiplied alpha blending
		gl.enable(gl.BLEND);
		gl.blendEquation(gl.FUNC_ADD);
		gl.blendFunc(gl.ONE, gl.ONE_MINUS_SRC_ALPHA);

		gl.enableVertexAttribArray(msdfProgram.attributeLocations.position);
		gl.enableVertexAttribArray(msdfProgram.attributeLocations.uv);

		gl.clearColor(0.1, 0.1, 0.1, 1);

		// set texture units
		gl.activeTexture(gl.TEXTURE0 + glyphAtlasTextureUnit);
		gl.bindTexture(gl.TEXTURE_2D, glyphAtlasTexture);

		frameLoop();

		function frameLoop() {
			window.requestAnimationFrame(frameLoop);
			const t = window.performance.now()/1000;

			gl.clear(gl.COLOR_BUFFER_BIT);

			// draw baseline
			gl.useProgram(msdfDebugProgram.deviceHandle);
			gl.uniformMatrix4fv(msdfDebugProgram.uniformLocations.transform, false, baselineTransform);
			gl.uniform4f(msdfDebugProgram.uniformLocations.color, 0.5, 0.8, 1, 1);
			gl.bindBuffer(gl.ARRAY_BUFFER, baselineBuffer);
			gl.vertexAttribPointer(msdfDebugProgram.attributeLocations.position, 2, gl.FLOAT, false, 2 * 4, 0);
			gl.vertexAttribPointer(msdfDebugProgram.attributeLocations.uv, 2, gl.FLOAT, false, 2 * 4, 0);
			gl.drawArrays(gl.LINES, 0, 2);
			

			const r = gl.drawingBufferWidth / gl.drawingBufferHeight;
			const s = debugSize.value;
			const sx = s / r;
			const sy = s;
			const x = -1;
			const y = 0;
			textTransform[0] = sx; textTransform[5] = sy;
			textTransform[12] = x; textTransform[13] = y;

			// draw text
			if (textBuffer != null && glyphAtlasTexture != null) {
				gl.useProgram(msdfProgram.deviceHandle);
				gl.uniformMatrix4fv(msdfProgram.uniformLocations.transform, false, textTransform);
				gl.uniform1i(msdfProgram.uniformLocations.glyphAtlas, glyphAtlasTextureUnit);
				gl.uniform1f(msdfProgram.uniformLocations.fieldRange, font.fieldRange_px);
				gl.uniform2f(msdfProgram.uniformLocations.resolution, gl.drawingBufferWidth, gl.drawingBufferHeight);

				gl.uniform4f(msdfProgram.uniformLocations.color, 1.0, 1.0, 1.0, 1.0);

				gl.bindBuffer(gl.ARRAY_BUFFER, textBuffer.deviceHandle);

				gl.vertexAttribPointer(
					msdfProgram.attributeLocations.position,
					textBuffer.layout.position.elements,
					gl.FLOAT,
					false,
					textBuffer.layout.position.strideBytes,
					textBuffer.layout.position.offsetBytes
				);
				gl.vertexAttribPointer(
					msdfProgram.attributeLocations.uv,
					textBuffer.layout.uv.elements,
					gl.FLOAT,
					false,
					textBuffer.layout.uv.strideBytes,
					textBuffer.layout.uv.offsetBytes
				);

				for (let i = 0; i < textBuffer.groups.length; i++) {
					let groups = textBuffer.groups[i];
					gl.drawArrays(textBuffer.drawMode, groups.vertexOffset, groups.vertexCount);
				}

				// debug: draw wireframe boxes
				if (debugModeCheckbox.checked) {
					gl.useProgram(msdfDebugProgram.deviceHandle);
					gl.uniformMatrix4fv(msdfDebugProgram.uniformLocations.transform, false, textTransform);
					gl.uniform1i(msdfDebugProgram.uniformLocations.glyphAtlas, glyphAtlasTextureUnit);
					let a = 0.2;
					gl.uniform4f(msdfDebugProgram.uniformLocations.color, 0 * a, 1 * a, 0 * a, a);
					for (let i = 0; i < textBuffer.groups.length; i++) {
						let groups = textBuffer.groups[i];
						gl.drawArrays(gl.LINE_STRIP, groups.vertexOffset, groups.vertexCount);
					}
				}
				
			}
		}

		// Debug Utils
		function logError(msg) {
			msg = Array.prototype.slice.call(arguments).join(', ');
			let isEmpty = document.querySelector('#error-log').innerHTML == '';
			document.querySelector('#error-log').innerHTML += (!isEmpty ? '\n': '') + '> ' + msg;
		}
	</script>
</body>
</html>